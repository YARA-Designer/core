<link rel="stylesheet" href="{{ url_for('static', filename='yara_rule_designer_click.css') }}">

<!-- Define default values for variables  -->
{% if artifacts is not defined %}
    {% set artifacts = {"data:" : "ERROR: NO ARTIFACTS WERE GIVEN!"} %}
{% endif %}

<!-- Load theme if specified -->
{% if theme is defined %}
    <!-- Set Jinja2 variables for use in JavaScript -->
    <!--    Theme handler: -->
    <meta id="themeArg" data-name="{{ theme }}" data-path="{{ url_for('static', filename='themes') + '/' }}">
    <!--    JavaScript custom POST handler -->
    <meta id="postUrl" data-url="{{ url_for('post_rule_json') }}">
    <!--    YARA rule variables gathered from backend for use in POST request -->
    <meta id="yaraRule" data-name="Whitelist_{{ case.data.title }}" data-tags="{{ case.data.tags }}">
    <meta id="yaraMeta" data-description="Whitelist regler for alarmen: Whitelist_{{ case.data.title }}">
{% endif %}


<div id="yara_rule_designer_header" class="yara_rule_designer"><p> Case: {{ case.data.title }} [ID: {{ case.data.id }}] </p></div>
<div id="yara_rule_designer_container">
    <div class="yara_rule_designer" id="yara_rule_designer_artifacts" ondrop="drop(event)" ondragover="dragOverDisallowedDrop(event)" ondragenter="dragEnterDenied(event)" ondragleave="dragLeaveDenied(event)">
        <!--    Add artifacts and artifact dataTypes as individual draggable objects-->

        <!-- Define list to filter artifact types so that only unique occurrences are added. -->
        {% set added_artifact_types = [] %}

        {% for artifact in artifacts %}
            <!-- Add artifacts -->
            <span id="artifact_{{ loop.index }}" class="draggable_artifact" onclick="addToEditor(event)" >{{ artifact.data }} </span>

            <!-- Add artifact dataTypes-->
            <!-- Remove NoneType entries by assigning the value to a new variable, if it is not NoneType. -->
            {% if artifact.dataType is not none and artifact.dataType != "None" %} <!-- <== Does literally nothing... (see workaround below)-->
                {% if artifact.dataType not in added_artifact_types %}
                    <!-- Only add unique items to editor -->
                    <span id="artifact_type_{{ loop.index }}" class="draggable_artifact_type" onclick="addToEditor(event)" >{{ artifact.dataType }} </span>
                    <!-- Workaround: Below line is commented (but still executed) in order to stop printing of "None" on the webpage for NoneType entries. -->
                    <!-- {{ added_artifact_types.append(artifact.dataType) }}-->
                {% endif %}
            {% endif %}
        {% endfor %}
    </div>
    <div id="yara_rule_designer_editor_container" class="yara_rule_designer">
        <div class="yara_rule_designer" id="yara_rule_designer_editor" ondrop="drop(event)" ondragover="dragOverAllowedDrop(event)" ondragenter="dragEnterAllowed(event)" ondragleave="dragLeaveAllowed(event)"></div>
        <div class="yara_rule_designer" id="yara_rule_designer_post" ondrop="drop(event)" ondragover="dragOverAllowedDrop(event)" ondragenter="dragEnterAllowed(event)" ondragleave="dragLeaveAllowed(event)">
            <button id="submit_rule_button" onclick="postRule()"></button>
        </div>
    </div>

    <div class="yara_rule_designer" id="yara_rule_designer_operators" ondrop="drop(event)" ondragover="dragOverDisallowedDrop(event)" ondragenter="dragEnterDenied(event)" ondragleave="dragLeaveDenied(event)">
    <!--    Add conditional keywords-->
    <!--    Boolean-->
        <span id="condition_keyword_and" class="condition_keyword" onclick="addToEditor(event)"> AND </span>
        <span id="condition_keyword_or" class="condition_keyword" onclick="addToEditor(event)"> OR </span>
        <span id="condition_keyword_not" class="condition_keyword" onclick="addToEditor(event)"> NOT </span>
    <!--    Arithmetic-->
        <span id="condition_keyword_equal" class="condition_keyword" onclick="addToEditor(event)"> == </span>
        <span id="condition_keyword_lt" class="condition_keyword" onclick="addToEditor(event)"> < </span>
        <span id="condition_keyword_gt" class="condition_keyword" onclick="addToEditor(event)"> > </span>
        <span id="condition_keyword_leq" class="condition_keyword" onclick="addToEditor(event)"> <= </span>
        <span id="condition_keyword_geq" class="condition_keyword" onclick="addToEditor(event)"> >= </span>
        <span id="condition_keyword_neq" class="condition_keyword" onclick="addToEditor(event)"> != </span>
    <!--    Relational-->
        <span id="condition_keyword_add" class="condition_keyword" onclick="addToEditor(event)"> + </span>
        <span id="condition_keyword_sub" class="condition_keyword" onclick="addToEditor(event)"> - </span>
        <span id="condition_keyword_mul" class="condition_keyword" onclick="addToEditor(event)"> * </span>
        <span id="condition_keyword_div" class="condition_keyword" onclick="addToEditor(event)"> / </span>
        <span id="condition_keyword_pct" class="condition_keyword" onclick="addToEditor(event)"> % </span>
        <span id="condition_keyword_setminus" class="condition_keyword" onclick="addToEditor(event)"> \ </span>
    <!--    Bitwise-->
        <span id="condition_keyword_bitwise_and" class="condition_keyword" onclick="addToEditor(event)"> & </span>
        <span id="condition_keyword_bitwise_or" class="condition_keyword" onclick="addToEditor(event)"> | </span>
        <span id="condition_keyword_bitwise_not" class="condition_keyword" onclick="addToEditor(event)"> ~ </span>
        <span id="condition_keyword_bitwise_xor" class="condition_keyword" onclick="addToEditor(event)"> ^ </span>
        <span id="condition_keyword_bitwise_lshift" class="condition_keyword" onclick="addToEditor(event)"> << </span>
        <span id="condition_keyword_bitwise_rshift" class="condition_keyword" onclick="addToEditor(event)"> >> </span>
    <!-- Parenthesis and wrappers       -->
        <span id="condition_keyword_lparen" class="condition_keyword" onclick="addToEditor(event)"> ( </span>
        <span id="condition_keyword_rparen" class="condition_keyword" onclick="addToEditor(event)"> ) </span>
        <span id="condition_keyword_encapsulate_paren" class="condition_encapsulator" onclick="addToEditor(event)"> () </span>
    </div>
</div>

<div id="info">
    <h1>How to use:</h1>
     <ul>
      <li>Click to add items to editor.</li>
      <li>Middle click to remove item from editor.</li>
      <li>Milk</li>
    </ul>
</div>

{% block javascript %}
    <!-- JQuery includes ( required for drag and drop and $() ). -->
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.0/jquery.min.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.9/jquery-ui.min.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.9/jquery-2.1.0.min.js"></script>

    <!-- Theme handler -->
    <script>

    // extend jQuery with this tiny convenience to allow for simple existence tests.
        $.fn.exists = function () {
            return this.length !== 0;
        };

        function loadTheme(themeData) {
            const rootEl = document.querySelector(':root');
            const themePath = themeData.path;

            let themeFile = themeData.name + ".json";
            let themeFilePath = themePath + themeFile;

            // Load corresponding theme JSON from file.
            console.log("Load theme: " + themeFilePath);
            $.getJSON(themeFilePath, function(json) {
                console.log(json); // this will show the info it in firebug console
                for (let key in json) {
                    console.log("setProperty(" + key + ", " + json[key] + ")")
                    rootEl.style.setProperty(key, json[key]);
                }

            });
        }

        let themeArg = $('#themeArg');

        if (themeArg.exists()) {
            loadTheme(themeArg.data())
        }
    </script>

    <script>
        // https://stackoverflow.com/a/26272668
        function getStyleRuleValue(selector, style) {
         let selector_compare=selector.toLowerCase();
         let selector_compare2= selector_compare.substr(0,1)==='.' ?  selector_compare.substr(1) : '.'+selector_compare;

         for (let i = 0; i < document.styleSheets.length; i++)
         {
          let mysheet = document.styleSheets[i];
          let myrules = mysheet.cssRules ? mysheet.cssRules : mysheet.rules;

          for (let j = 0; j < myrules.length; j++)
          {
            if (myrules[j].selectorText)
            {
             let check = myrules[j].selectorText.toLowerCase();
             switch (check)
             {
              case selector_compare  :
              case selector_compare2 : return myrules[j].style[style];
             }
            }
           }
          }
         }

        const ROOT_CLASS = 'yara_rule_designer';
        const DIVS_WITH_CLONING = ['yara_rule_designer_artifacts', 'yara_rule_designer_operators'];

        let originalParentIdLookupByClass = {
            "draggable_artifact": "yara_rule_designer_artifacts",
            "condition_keyword": "yara_rule_designer_operators",
            "condition_encapsulator": "yara_rule_designer_operators"
        };

        // Convenience/readability constants.
        const LEFT_CLICK = 0;
        const MIDDLE_CLICK = 1;
        const RIGHT_CLICK = 2;

        /**
         * Override default behaviour for mouse clicks in the editor div,
         * in order to support middle and right clicks.
         */
        document.getElementById('yara_rule_designer_editor').addEventListener('auxclick', function(ev) {
          console.log(ev.button);
          // Prevent default action in order to implement our own.
          ev.preventDefault();

          // Handle aux click events.
          onAuxClick(ev);
        });

        /**
         * Because null == undefined is true, this will catch both null and undefined.
         */
        function hasRelatedTarget(ev) {
            return ev.relatedTarget != null;
        }

        /**
         * Because null == undefined is true, this will catch both null and undefined.
         */
        function hasTarget(ev) {
            return ev.target != null;
        }

        /**
         * Get the identifying property of the item when getAttribute isn't inherited.
         */
        function getIdentifier(target) {
            if (target.nodeName === "#text") {
                return target.data + " [type: #text]";
            } else {
                return target.getAttribute('id');
            }
        }

        function addToEditor(clickEvent) {
            let editorDiv = document.getElementById("yara_rule_designer_editor");

            // If target is already in the editor, ignore the click event.
            if (clickEvent.target.parentNode.getAttribute("id") === "yara_rule_designer_editor") {
                console.log("Ignored click event (target is child of editor div):");
                console.log(clickEvent);
                return
            }

            // console.log(clickEvent);


            console.log('addToEditor: ' + $(clickEvent.target).text());
            editorDiv.appendChild(makeClone(clickEvent.target));
        }

        function removeFromEditor(clickEvent) {
            let editorDiv = document.getElementById("yara_rule_designer_editor");

            // Only perform remove action if target is a child of editor div.
            if (clickEvent.target.parentNode.getAttribute("id") === "yara_rule_designer_editor") {
                console.log("removeFromEditor: " + $(clickEvent.target).text());
                editorDiv.removeChild(clickEvent.target);
            }
        }

        function onAuxClick(auxClickEvent) {
            console.log("onAuxClick:");
            console.log(auxClickEvent);

            // Check which mouse button was pressed and act accordingly.
            switch (auxClickEvent.button) {
                case MIDDLE_CLICK:
                    removeFromEditor(auxClickEvent);
                    break;
                case RIGHT_CLICK:
                    break;
            }
        }

        // /**
        //  * Generate a JSON of varname and vardata to send in POST request.
        //  */
        // function getRuleConditionFromEditorElements() {
        //     let json = {};
        //
        //     return json;
        // }

        /**
         * Generate a JSON of varname and vardata to send in POST request.
         */
        function getRuleJsonFromEditorElements() {
            let json = {};
            let yaraRule = $('#yaraRule').data();

            // Get rule name
            let ruleName = yaraRule.name;

            // Set meta FIXME: sub-dicts hardcoded!
            json["meta"] = {"description" : $('#yaraMeta').data().description};

            // Set rule name
            json["rule"] = ruleName;

            // Set tags.
            json["tags"] = yaraRule.tags;
            console.log(json["tags"]);

            // TODO: Get list of artifacts (varname, data) in editor div
            // TODO: <Insert some sort of loop here>
            json["artifacts"] = {
                "artifacts" : {
                        "artifact": "FIXME: Artifacts NOT implemented!",
                        "id": "FIXME_NOT_AN_ID",
                        "type": "FIXME"
                },
            };

            // TODO: Get condition
            json["condition"] = "FIXME: Condition NOT Implemented!";

            return json;
        }

        /**
         * Make a custom POST request for non-form elements like DIV and SPAN.
         */
        function postRule() {
            let json = getRuleJsonFromEditorElements();

            let xhr = new XMLHttpRequest();
            let postUrl = $('#postUrl').data().url;

            console.log("POST URL: " + postUrl);

            xhr.open("POST", postUrl, true);
            xhr.setRequestHeader('Content-Type', 'application/json');

            // Convert a JavaScript value to a JavaScript Object Notation (JSON) string (Required for POST).
            xhr.send(JSON.stringify(json));
        }

        //////
        /**
         * Make clone width and height static.
         * Take clone out of the element flow.
         *
         * @param {HTMLElement} node
         * @param {Number} width
         * @param {Number} height
         */
        function styleClone(node, width, height) {
            node.style.position = 'fixed';
            node.style.zIndex = 9999;
            node.style.width = width + 'px';
            node.style.height = height + 'px';
            node.style.left = '-9999px';

            node.style.margin = 0;
            node.style.padding = 0;
        }


        function makeClone(node) {
            console.log(node);
            let clone;

            // Returns a copy of node. If deep is true, the copy also includes the node's descendants.
            clone = node.cloneNode(true);

            node.parentNode.insertBefore(clone, node);

            return clone;
        }
    </script>
{% endblock %}